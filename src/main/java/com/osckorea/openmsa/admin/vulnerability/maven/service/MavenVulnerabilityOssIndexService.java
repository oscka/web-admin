package com.osckorea.openmsa.admin.vulnerability.maven.service;

import java.util.ArrayList;
import java.util.Date;
import java.util.stream.Stream;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.osckorea.openmsa.admin.vulnerability.common.dto.ComponentDto;
import com.osckorea.openmsa.admin.vulnerability.common.dto.VulnerabilityReportDto;
import com.osckorea.openmsa.admin.vulnerability.common.dto.types.Component;
import com.osckorea.openmsa.admin.vulnerability.common.dto.types.VulnerabilityReport;
import com.osckorea.openmsa.admin.vulnerability.common.feign.ComponentFeignClient;
import com.osckorea.openmsa.admin.vulnerability.common.feign.VulnerabilityAuthFeignClient;
import com.osckorea.openmsa.admin.vulnerability.common.feign.VulnerabilityFeignClient;
import com.osckorea.openmsa.admin.vulnerability.maven.domain.MavenVulnerabilityDetail;
import com.osckorea.openmsa.admin.vulnerability.maven.domain.MavenVulnerabilityDetailPrimaryKey;
import com.osckorea.openmsa.admin.vulnerability.maven.domain.MavenVulnerabilityHeader;
import com.osckorea.openmsa.admin.vulnerability.maven.repository.MavenVulnerabilityDetailRepository;
import com.osckorea.openmsa.admin.vulnerability.maven.repository.MavenVulnerabilityHeaderRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@RequiredArgsConstructor
public class MavenVulnerabilityOssIndexService {
    private final ComponentFeignClient componentFeignClient;
    private final VulnerabilityFeignClient vulnerabilityFeignClient;
    private final VulnerabilityAuthFeignClient vulnerabilityAuthFeignClient;

    private final MavenVulnerabilityDetailRepository mavenVulnerabilityDetailRepository;
    private final MavenVulnerabilityHeaderRepository mavenVulnerabilityHeaderRepository;

    /**
     * SonaType OSS Index API를 호출합니다.
     * 
     * @param group : Component의 GroupId입니다.
     * @param name : Component의 Name입니다.
     * @param version : Component의 Version입니다.
     * 
     * @return 특정 Component에 대한 취약점 정보 목록을 반환합니다.
     */
    @Transactional
    public VulnerabilityReportDto.Response getComponentVulnerability(String group, String name, String version) {
        VulnerabilityReportDto.Request request = VulnerabilityReportDto.Request.builder().coordinates(new String[] {this.getPackageUrlString(group, name, version)}).build();

        VulnerabilityReportDto.Response response = this.vulnerabilityFeignClient.getComponentVulnerabilityReports(request)[0];

        if(response.getVulnerabilities().length > 0) {
            Integer criticalCount = 0;
            Integer severeCount = 0;
            Integer moderateCount = 0;

            for(VulnerabilityReport report : response.getVulnerabilities()) {
                MavenVulnerabilityDetailPrimaryKey primaryKey = MavenVulnerabilityDetailPrimaryKey.builder().componentPackageUrl(response.getCoordinates()).id(report.getId()).build();
    
                MavenVulnerabilityDetail detailData = MavenVulnerabilityDetail.builder()
                                                                    .primaryKey(primaryKey)
                                                                    .displayName(report.getDisplayName())
                                                                    .title(report.getTitle())
                                                                    .descripton(report.getTitle())
                                                                    .cvssScore(report.getCvssScore())
                                                                    .cvssVector(report.getCvssVector())
                                                                    .cwe(report.getCwe())
                                                                    .cve(report.getCve())
                                                                    .referenceUrl(report.getReference())
                                                                    .externalReferenceUrl(report.getExternalReferences())
                                                                    .build();
                                                    
                if(report.getCvssScore() >= 7) {
                    criticalCount++;
                } else if(report.getCvssScore() >= 4) {
                    severeCount++;
                } else {
                    moderateCount++;
                }

                this.mavenVulnerabilityDetailRepository.findByPrimaryKey(primaryKey).orElseGet(() -> this.mavenVulnerabilityDetailRepository.save(detailData));
            }

            MavenVulnerabilityHeader headerData = MavenVulnerabilityHeader.builder()
                                                                .componentPackageUrl(response.getCoordinates())
                                                                .componentDescription(response.getDescription())
                                                                .componentReferenceUrl(response.getReference())
                                                                .vulnerabilityCriticalCount(criticalCount)
                                                                .vulnerabilitySevereCount(severeCount)
                                                                .vulnerabilityModerateCount(moderateCount)
                                                                .build();

            this.mavenVulnerabilityHeaderRepository.findById(response.getCoordinates()).ifPresentOrElse(data -> {
                if(calcDiffDays(data.getLastModifiedDate().getTime(), new Date(System.currentTimeMillis()).getTime())) {
                    headerData.setNew(false);
    
                    this.mavenVulnerabilityHeaderRepository.save(headerData);
                }
            }, () -> this.mavenVulnerabilityHeaderRepository.save(headerData));
        }

        return response;
    }

    /**
     * 사용자 권한을 인증한 SonaType OSS Index API를 호출합니다.
     * 
     * @param basicAuthToken : Basic Auth 방식의 토큰 문자열입니다. ex) Basic {username}:{password}
     * @param group : Component의 GroupId입니다.
     * @param name : Component의 Name입니다.
     * @param version : Component의 Version입니다.
     * 
     * @return 특정 Component에 대한 취약점 정보 목록을 반환합니다.
     */
    @Transactional
    public VulnerabilityReportDto.Response getComponentVulnerabilityWithAuth(String basicAuthToken, String group, String name, String version) {
        VulnerabilityReportDto.Request request = VulnerabilityReportDto.Request.builder().coordinates(new String[] {this.getPackageUrlString(group, name, version)}).build();

        VulnerabilityReportDto.Response response = this.vulnerabilityAuthFeignClient.getComponentVulnerabilityReports(basicAuthToken, request)[0];

        if(response.getVulnerabilities().length > 0) {
            Integer criticalCount = 0;
            Integer severeCount = 0;
            Integer moderateCount = 0;

            for(VulnerabilityReport report : response.getVulnerabilities()) {
                MavenVulnerabilityDetailPrimaryKey primaryKey = MavenVulnerabilityDetailPrimaryKey.builder().componentPackageUrl(response.getCoordinates()).id(report.getId()).build();
    
                MavenVulnerabilityDetail detailData = MavenVulnerabilityDetail.builder()
                                                                    .primaryKey(primaryKey)
                                                                    .displayName(report.getDisplayName())
                                                                    .title(report.getTitle())
                                                                    .descripton(report.getTitle())
                                                                    .cvssScore(report.getCvssScore())
                                                                    .cvssVector(report.getCvssVector())
                                                                    .cwe(report.getCwe())
                                                                    .cve(report.getCve())
                                                                    .referenceUrl(report.getReference())
                                                                    .externalReferenceUrl(report.getExternalReferences())
                                                                    .build();
                                                    
                if(report.getCvssScore() >= 7) {
                    criticalCount++;
                } else if(report.getCvssScore() >= 4) {
                    severeCount++;
                } else {
                    moderateCount++;
                }

                // 현재 Detail Data가 있는지 검사하고 없으면, 저장용 목록에 추가합니다.
                this.mavenVulnerabilityDetailRepository.findByPrimaryKey(primaryKey).orElseGet(() -> this.mavenVulnerabilityDetailRepository.save(detailData));
            }

            MavenVulnerabilityHeader headerData = MavenVulnerabilityHeader.builder()
                                                                .componentPackageUrl(response.getCoordinates())
                                                                .componentDescription(response.getDescription())
                                                                .componentReferenceUrl(response.getReference())
                                                                .vulnerabilityCriticalCount(criticalCount)
                                                                .vulnerabilitySevereCount(severeCount)
                                                                .vulnerabilityModerateCount(moderateCount)
                                                                .build();

            this.mavenVulnerabilityHeaderRepository.findById(response.getCoordinates()).ifPresentOrElse(data -> {
                if(calcDiffDays(data.getLastModifiedDate().getTime(), new Date(System.currentTimeMillis()).getTime())) {
                    headerData.setNew(false);
    
                    this.mavenVulnerabilityHeaderRepository.save(headerData);
                }
            }, () -> this.mavenVulnerabilityHeaderRepository.save(headerData));
        }

        return response;
    }

    @Transactional
    public VulnerabilityReportDto.Response[] getComponentVulnerabilities(String name) {
        int cnt = 0;

        ArrayList<String> componetPackageUrlList = new ArrayList<String>();
        ArrayList<VulnerabilityReportDto.Response> vulnerabilityReportList = new ArrayList<VulnerabilityReportDto.Response>();

        VulnerabilityReportDto.Request vulnerabilityRequestData = null;

        ArrayList<MavenVulnerabilityHeader> headerDataList = new ArrayList<MavenVulnerabilityHeader>();
        ArrayList<MavenVulnerabilityDetail> detailDataList = new ArrayList<MavenVulnerabilityDetail>();

        ComponentDto componentList = this.componentFeignClient.getComponentList(name);

        while(componentList.getContinuationToken() != null) {
            log.info("{} 번째 반복입니다.", ++cnt);

            log.info("120개 Component Url을 추출합니다.");
            // Component 120개에 대한 PackageUrl 목록을 추가합니다.
            while(componentList.getContinuationToken() != null & componetPackageUrlList.size() < 120) {

                for (Component component : componentList.getItems()) {
                    componetPackageUrlList.add(getPackageUrlString(component.getGroup(), component.getName(), component.getVersion()));
                }

                componentList = this.componentFeignClient.getComponentList(componentList.getContinuationToken(), name);
            }

            log.info("전송 데이터를 생성합니다.");
            // 120개의 Component 목록에 대하여, 취약점 목록 요청 API에 전송할, Body Data를 생성합니다.
            vulnerabilityRequestData = VulnerabilityReportDto.Request.builder().coordinates(componetPackageUrlList.toArray(String[]::new)).build();

            log.info("데이터를 요청합니다.");
            // 취약점 목록
            VulnerabilityReportDto.Response[] vulnerabilityResponse = this.vulnerabilityFeignClient.getComponentVulnerabilityReports(vulnerabilityRequestData);

            log.info("프로세스 수행");
            Stream.of(vulnerabilityResponse)
                    .parallel()
                    .filter(report -> report.getVulnerabilities().length > 0)
                    .forEach(report -> {
                        vulnerabilityReportList.add(report);

                        Integer criticalCount = 0;
                        Integer severeCount = 0;
                        Integer moderateCount = 0;

                        for (VulnerabilityReport data :report.getVulnerabilities()) {
                            MavenVulnerabilityDetailPrimaryKey primaryKey = MavenVulnerabilityDetailPrimaryKey.builder().componentPackageUrl(report.getCoordinates()).id(data.getId()).build();

                            MavenVulnerabilityDetail detailData = MavenVulnerabilityDetail.builder()
                                                                                .primaryKey(primaryKey)
                                                                                .displayName(data.getDisplayName())
                                                                                .title(data.getTitle())
                                                                                .descripton(data.getDescription())
                                                                                .cvssScore(data.getCvssScore())
                                                                                .cvssVector(data.getCvssVector())
                                                                                .cwe(data.getCwe())
                                                                                .cve(data.getCve())
                                                                                .referenceUrl(data.getReference())
                                                                                .externalReferenceUrl(data.getExternalReferences())
                                                                                .build();

                            if (data.getCvssScore() >= 7) {
                                criticalCount++;
                            } else if(data.getCvssScore() >= 4) {
                                severeCount++;
                            } else {
                                moderateCount++;
                            }

                            if (this.mavenVulnerabilityDetailRepository.findByPrimaryKey(primaryKey).isEmpty()) {
                                detailDataList.add(detailData);
                            }
                        }

                        MavenVulnerabilityHeader headerData = MavenVulnerabilityHeader.builder()
                                                                            .componentPackageUrl(report.getCoordinates())
                                                                            .componentDescription(report.getDescription() != null ? report.getDescription() : "")
                                                                            .componentReferenceUrl(report.getReference())
                                                                            .vulnerabilityCriticalCount(criticalCount)
                                                                            .vulnerabilitySevereCount(severeCount)
                                                                            .vulnerabilityModerateCount(moderateCount)
                                                                            .build();

                        this.mavenVulnerabilityHeaderRepository.findById(report.getCoordinates()).ifPresentOrElse(data -> {
                            if(calcDiffDays(data.getLastModifiedDate().getTime(), new Date(System.currentTimeMillis()).getTime())) {
                                headerData.setNew(false);

                                headerDataList.add(headerData);
                            } 
                        }, () -> headerDataList.add(headerData));
                    });
            
            this.mavenVulnerabilityHeaderRepository.saveAll(headerDataList);
            this.mavenVulnerabilityDetailRepository.saveAll(detailDataList);

            componetPackageUrlList.clear();
            headerDataList.clear();
            detailDataList.clear();
        }

        return vulnerabilityReportList.toArray(VulnerabilityReportDto.Response[]::new);
    }

    @Transactional
    public VulnerabilityReportDto.Response[] getComponentVulnerabilitiesWithAuth(String basicAuthToken, String name) {
        int cnt = 0;

        ArrayList<String> componetPackageUrlList = new ArrayList<String>();
        ArrayList<VulnerabilityReportDto.Response> vulnerabilityReportList = new ArrayList<VulnerabilityReportDto.Response>();

        VulnerabilityReportDto.Request vulnerabilityRequestData = null;

        ArrayList<MavenVulnerabilityHeader> headerDataList = new ArrayList<MavenVulnerabilityHeader>();
        ArrayList<MavenVulnerabilityDetail> detailDataList = new ArrayList<MavenVulnerabilityDetail>();

        ComponentDto componentList = this.componentFeignClient.getComponentList(name);

        while(componentList.getContinuationToken() != null) {
            log.info("{} 번째 반복입니다.", ++cnt);

            // Component 120개에 대한 PackageUrl 목록을 추가합니다.
            while(componentList.getContinuationToken() != null & componetPackageUrlList.size() < 120) {
                log.info("120개 Component Url을 추출합니다.");

                for (Component component : componentList.getItems()) {
                    componetPackageUrlList.add(getPackageUrlString(component.getGroup(), component.getName(), component.getVersion()));
                }

                componentList = this.componentFeignClient.getComponentList(componentList.getContinuationToken(), name);
            }

            log.info("전송 데이터를 생성합니다.");
            // 120개의 Component 목록에 대하여, 취약점 목록 요청 API에 전송할, Body Data를 생성합니다.
            vulnerabilityRequestData = VulnerabilityReportDto.Request.builder().coordinates(componetPackageUrlList.toArray(String[]::new)).build();

            log.info("데이터를 요청합니다.");
            // 취약점 목록
            VulnerabilityReportDto.Response[] vulnerabilityResponse = this.vulnerabilityAuthFeignClient.getComponentVulnerabilityReports(basicAuthToken, vulnerabilityRequestData);

            log.info("프로세스 수행");
            Stream.of(vulnerabilityResponse)
                    .parallel()
                    .filter(report -> report.getVulnerabilities().length > 0)
                    .forEach(report -> {
                        vulnerabilityReportList.add(report);

                        Integer criticalCount = 0;
                        Integer severeCount = 0;
                        Integer moderateCount = 0;

                        for (VulnerabilityReport data :report.getVulnerabilities()) {
                            MavenVulnerabilityDetailPrimaryKey primaryKey = MavenVulnerabilityDetailPrimaryKey.builder().componentPackageUrl(report.getCoordinates()).id(data.getId()).build();

                            MavenVulnerabilityDetail detailData = MavenVulnerabilityDetail.builder()
                                                                                .primaryKey(primaryKey)
                                                                                .displayName(data.getDisplayName())
                                                                                .title(data.getTitle())
                                                                                .descripton(data.getDescription())
                                                                                .cvssScore(data.getCvssScore())
                                                                                .cvssVector(data.getCvssVector())
                                                                                .cwe(data.getCwe())
                                                                                .cve(data.getCve())
                                                                                .referenceUrl(data.getReference())
                                                                                .externalReferenceUrl(data.getExternalReferences())
                                                                                .build();

                            if (data.getCvssScore() >= 7) {
                                criticalCount++;
                            } else if(data.getCvssScore() >= 4) {
                                severeCount++;
                            } else {
                                moderateCount++;
                            }

                            if (this.mavenVulnerabilityDetailRepository.findByPrimaryKey(primaryKey).isEmpty()) {
                                detailDataList.add(detailData);
                            }
                        }

                        MavenVulnerabilityHeader headerData = MavenVulnerabilityHeader.builder()
                                                                            .componentPackageUrl(report.getCoordinates())
                                                                            .componentDescription(report.getDescription())
                                                                            .componentReferenceUrl(report.getReference())
                                                                            .vulnerabilityCriticalCount(criticalCount)
                                                                            .vulnerabilitySevereCount(severeCount)
                                                                            .vulnerabilityModerateCount(moderateCount)
                                                                            .build();

                        this.mavenVulnerabilityHeaderRepository.findById(report.getCoordinates()).ifPresentOrElse(data -> {
                            if(calcDiffDays(data.getLastModifiedDate().getTime(), new Date(System.currentTimeMillis()).getTime())) {
                                headerData.setNew(false);

                                headerDataList.add(headerData);
                            } 
                        }, () -> headerDataList.add(headerData));
                    });
            
            this.mavenVulnerabilityHeaderRepository.saveAll(headerDataList);
            this.mavenVulnerabilityDetailRepository.saveAll(detailDataList);

            componetPackageUrlList.clear();
            headerDataList.clear();
            detailDataList.clear();
        }

        return vulnerabilityReportList.toArray(VulnerabilityReportDto.Response[]::new);
    }

    /**
     * 
     * @param componentGroup : 컴포넌트 그룹 명
     * @param componentName : 컴포넌트 이름
     * @param componentVersion : 컴포넌트 버전
     * 
     * @return "pkg:maven/{componentGroup}/{componentName}@{componentVersion}"
     */
    private String getPackageUrlString(String componentGroup, String componentName, String componentVersion) {
        StringBuilder componentVulnerabilityRequestData = new StringBuilder("pkg:maven");

        componentVulnerabilityRequestData.append("/");
        componentVulnerabilityRequestData.append(componentGroup);
        componentVulnerabilityRequestData.append("/");
        componentVulnerabilityRequestData.append(componentName);
        componentVulnerabilityRequestData.append("@");
        componentVulnerabilityRequestData.append(componentVersion);

        return componentVulnerabilityRequestData.toString();
    }

    /**
     * 
     * @param username : SonaType OSS Index 사용자 이메일
     * @param password : SonaType OSS Index 사용자 API Token
     * 
     * @return "Basic {username:password :: StringToBase64}"
     */
    // private String convertBasicAuthToken(String username, String password) {
    //     return "Basic " + Base64.getEncoder().encodeToString(String.join(":", username, password).getBytes()).toString();
    // }

    private Boolean calcDiffDays(Long targetDateToSecond, Long compareDateToSecond) {
        Long diffDays = ((targetDateToSecond - compareDateToSecond) - 1000 ) / (24*60*60);

        if(diffDays >= 7) {
            return true;
        } else {
            return false;
        }
    }
}
